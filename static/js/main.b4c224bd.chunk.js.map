{"version":3,"sources":["logo.svg","components/RestoreButton/index.js","components/BackupButton/index.js","components/AppExplanations/index.js","App.js","index.js","controller/PasswordsManager.js"],"names":["RestoreButton","text","color","disabled","hidden","onClick","useState","isLoading","setLoading","file","useRef","hasFileInputBeenCanceled","current","value","length","document","body","onfocus","onTriggerFileSelect","useCallback","click","onSelectedFileChanged","event","target","files","then","className","style","margin","backgroundColor","display","type","ref","onChange","accept","BackupButton","onTriggerRunThenSaveFile","fileData","blob","Blob","JSON","stringify","url","URL","createObjectURL","elem","createElement","href","download","appendChild","removeChild","downloadFile","AppExplanations","expandedItems","setexpandedItems","allowZeroExpanded","allowMultipleExpanded","update","newExpandedItemUUID","itemButtonBottom","getElementById","getBoundingClientRect","bottom","window","innerHeight","scrollBy","children","passwordsManager","PasswordsManager","listen","log","console","App","ask_device","device_handler","request","Promise","resolve","a","result","connected","connect","setConnected","toast","info","autoClose","setBusy","dismiss","success","disconnect","error","toString","isBusy","isConnected","hideProgressBar","src","logo","alt","dump_metadatas","metadatas","load_metadatas","packageJson","version","ReactDOM","render","StrictMode","insAPDU","Object","freeze","GET_APP_INFO_COMMAND","GET_APP_CONFIG_COMMAND","DUMP_METADATAS_COMMAND","LOAD_METADATAS_COMMAND","passwordsCharsets","UPPERCASE","LOWERCASE","NUMBERS","MINUS","UNDERLINE","SPACE","SPECIAL","BRACKETS","this","allowedStatuses","busy","transport","TransportWebUSB","create","getAppInfo","appName","Error","getAppConfig","appConfig","storage_size","close","readUInt16BE","errors","charsets","bitmask","charset","charsetList","push","json_metadatas","Buffer","alloc","parsed_metadatas","parse","offset","forEach","element","nickname","_charsetListToBitmask","write","metadatas_list","erased_list","corruptions","len","erased","metadata","slice","_bitmaskToCharsetList","parsed","nicknames_erased_but_still_stored","corruptions_encountered","raw_metadatas","chunk","is_last","send","from","isSuccess","mapProtocolError","_lock","app_name_length","app_name","app_version_length","app_version","_unlock","readUInt32BE","keyboard_type","press_enter_after_typing","concat","_toJSON","JSON_metadatas","_toBytes","i","_load_metadatas_chunk"],"mappings":"kQAAe,MAA0B,iC,MCmD1BA,MAhDf,YAAoE,IAA3CC,EAA0C,EAA1CA,KAAMC,EAAoC,EAApCA,MAAOC,EAA6B,EAA7BA,SAAUC,EAAmB,EAAnBA,OAAQC,EAAW,EAAXA,QAAW,EACjCC,oBAAS,GADwB,mBAC1DC,EAD0D,KAC/CC,EAD+C,KAE3DC,EAAOC,iBAAO,MAEdC,EAA2B,WAC1BF,EAAKG,QAAQC,MAAMC,QAAQN,GAAW,GAC3CO,SAASC,KAAKC,QAAU,MAGpBC,EAAsBC,uBAAY,WACtCX,GAAW,GACXO,SAASC,KAAKC,QAAUN,EACxBF,EAAKG,SAAWH,EAAKG,QAAQQ,UAC5B,IAEGC,EAAwBF,uBAC5B,SAACG,GACCA,EAAMC,OAAOC,MAAM,GAAGvB,OAAOwB,MAAK,SAACxB,GACjCqB,EAAMC,OAAOV,MAAQ,GACrBR,EAAQJ,GAAMwB,MAAK,kBAAMjB,GAAW,WAGxC,CAACH,IAGH,OACE,yBACEqB,UAAU,gBACVvB,SAAUI,EAAYJ,EACtBE,QAASE,EAAY,KAAOW,EAC5BS,MAAO,CACLC,OAAQ,OACRC,gBAAiB3B,EACjB4B,SAAS1B,GAAS,QAPtB,UAUGG,EAAY,gBAAaN,EAC1B,uBACE8B,KAAK,OACLC,IAAKvB,EACLwB,SAAUZ,EACVa,OAAO,QACPP,MAAO,CAAEG,QAAS,c,MCFXK,MA3Bf,YAAmE,IAA3ClC,EAA0C,EAA1CA,KAAMC,EAAoC,EAApCA,MAAOC,EAA6B,EAA7BA,SAAUC,EAAmB,EAAnBA,OAAQC,EAAW,EAAXA,QAAW,EAChCC,oBAAS,GADuB,mBACzDC,EADyD,KAC9CC,EAD8C,KAG1D4B,EAA2BjB,uBAAY,WAC3CX,GAAW,GACXH,IAAUoB,MAAK,SAACY,GACVA,GAnBV,SAAsBA,GACpB,IAAIC,EAAO,IAAIC,KAAK,CAACC,KAAKC,UAAUJ,EAAU,KAAM,IAAK,CACvDN,KAAM,mCAEJW,EAAMC,IAAIC,gBAAgBN,GAC1BO,EAAO9B,SAAS+B,cAAc,KAClCD,EAAKE,KAAOL,EACZG,EAAKG,SAAW,cAChBjC,SAASC,KAAKiC,YAAYJ,GAC1BA,EAAKzB,QACLL,SAASC,KAAKkC,YAAYL,GASRM,CAAad,GAC3B7B,GAAW,QAEZ,CAACH,IAEJ,OACE,wBACEqB,UAAU,eACVvB,SAAUI,EAAYJ,EACtBE,QAASE,EAAY,KAAO6B,EAC5BT,MAAO,CACLC,OAAQ,OACRC,gBAAiB3B,EACjB4B,SAAS1B,GAAS,QAPtB,SAUGG,EAAY,gBAAaN,K,uCC1BjB,SAASmD,IAAmB,IAAD,EACE9C,mBAAS,IADX,mBACjC+C,EADiC,KAClBC,EADkB,KAwCxC,OACE,eAAC,IAAD,CAAWC,mBAAiB,EAACC,uBAAqB,EAACvB,SArCrD,SAAsBwB,GACpB,GAAIA,EAAO3C,OAASuC,EAAcvC,OAAQ,CACxC,IAAM4C,EAAsBD,EAAOA,EAAO3C,OAAS,GAC7C6C,EAAmB5C,SACtB6C,eADsB,2BACaF,IACnCG,wBAAwBC,OACvBH,EAAmBI,OAAOC,aAC5BD,OAAOE,SAAS,EAAGN,EAAmBI,OAAOC,aAGjDV,EAAiBG,IA2BjB,UACE,eAAC,IAAD,WACE,cAAC,IAAD,UACE,cAAC,IAAD,uCAEF,cAAC,IAAD,UACE,cAAC,IAAD,CACE/B,UAAU,eACVwC,SA9BR,60BAkCE,eAAC,IAAD,WACE,cAAC,IAAD,UACE,cAAC,IAAD,2DAIF,cAAC,IAAD,UACE,cAAC,IAAD,CACExC,UAAU,eACVwC,SArCR,6IAyCE,eAAC,IAAD,WACE,cAAC,IAAD,UACE,cAAC,IAAD,0CAEF,cAAC,IAAD,UACE,cAAC,IAAD,CACExC,UAAU,eACVwC,SA5CR,42BAgDE,eAAC,IAAD,WACE,cAAC,IAAD,UACE,cAAC,IAAD,yEAIF,cAAC,IAAD,UACE,cAAC,IAAD,CACExC,UAAU,eACVwC,SApDR,2SAwDE,eAAC,IAAD,WACE,cAAC,IAAD,UACE,cAAC,IAAD,sCAEF,cAAC,IAAD,UACE,cAAC,IAAD,CACExC,UAAU,eACVwC,SA3DR,sqB,qCCtCEC,G,OAAmB,IAAIC,KAC7BC,aAAO,SAACC,GACNC,QAAQD,IAAIA,MA4FCE,MAzFf,WACE,SAASC,EAAWC,EAAgBC,GAClC,OAAO,IAAIC,QAAJ,uCAAY,WAAOC,GAAP,eAAAC,EAAA,yDACbC,EAAS,KADI,SAGVL,EAAeM,UAHL,gCAIPN,EAAeO,UAJR,OAKbC,GAAa,GACbC,IAAMC,KAAK,gCAAuB,CAAEC,WAAW,IANlC,WAQXV,EARW,wBASbQ,IAAMC,KAAK,uCAAmC,CAAEC,WAAW,IAC3DC,GAAQ,GAVK,UAWEX,IAXF,QAWbI,EAXa,OAabI,IAAMI,UACNJ,IAAMK,QAAQ,wBAdD,0DAiBfd,EAAee,aACfP,GAAa,GACbC,IAAMI,UACNJ,IAAMO,MAAN,UAAe,KAAMC,WAArB,kBApBe,yBAsBfL,GAAQ,GACRT,EAAQE,GAvBO,6EAAZ,uDAFI,MAgCazE,oBAAS,GAhCtB,mBAgCNsF,EAhCM,KAgCEN,EAhCF,OAiCuBhF,oBAAS,GAjChC,mBAiCNuF,EAjCM,KAiCOX,EAjCP,KAmCb,OACE,sBAAKxD,UAAU,MAAf,UACE,cAAC,IAAD,CAAgBoE,iBAAiB,IACjC,sBAAKpE,UAAU,aAAf,UACE,qBAAKqE,IAAKC,EAAMtE,UAAU,WAAWuE,IAAI,SACzC,mBAAGvE,UAAU,YAAb,iCAEF,yBAAQA,UAAU,aAAlB,UACE,sBAAKA,UAAU,WAAf,UACE,cAAC,EAAD,CACEzB,KAAK,UACLC,MAAM,UACNC,SAAUyF,EACVxF,OAAQyF,EACRxF,QAAS,kBAAMoE,EAAWN,MAE5B,cAAC,EAAD,CACElE,KAAK,SACLC,MAAM,UACNC,SAAUyF,EACVxF,QAASyF,EACTxF,QAAS,kBACPoE,EAAWN,GAAkB,kBAC3BA,EAAiB+B,uBAIvB,cAAC,EAAD,CACEjG,KAAK,UACLC,MAAM,UACNC,SAAUyF,EACVxF,QAASyF,EACTxF,QAAS,SAAC8F,GAAD,OACP1B,EAAWN,GAAkB,kBAC3BA,EAAiBiC,eAAeD,YAKxC,cAAC,EAAD,IACA,qBAAKzE,UAAU,aAAf,SACE,2GAEM2E,EAAYC,SAFlB,IAE8B,IAC5B,mBAAGvD,KAAK,+CAAR,6DC3FZwD,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF1F,SAAS6C,eAAe,U,gHCPpB8C,EAAUC,OAAOC,OAAO,CAC5BC,qBAAsB,EACtBC,uBAAwB,EACxBC,uBAAwB,EACxBC,uBAAwB,IAGpBC,EAAoBN,OAAOC,OAAO,CACtCM,UAAW,EACXC,UAAW,EACXC,QAAS,EACTC,MAAO,EACPC,UAAW,GACXC,MAAO,GACPC,QAAS,GACTC,SAAU,MAKNrD,E,WACJ,aAAe,oBACbsD,KAAKC,gBAAkB,CACrB,MACA,MACA,MACA,MACA,MACA,MACA,OAEFD,KAAK1C,WAAY,EACjB0C,KAAKE,MAAO,EACZF,KAAKG,UAAY,K,iLAIZH,KAAK1C,U,oBACH0C,KAAKG,U,gCAAkCC,IAAgBC,S,OAAvCL,KAAKG,U,uCAESH,KAAKM,a,sCAA/BC,E,KAAS3B,E,KACW,cAAvB2B,EAAQtC,W,uBACJ,IAAIuC,MAAM,iD,eAClBR,KAAKpB,QAAUA,E,UACOoB,KAAKS,e,QAAvBC,E,OACJV,KAAKW,aAAeD,EAAS,aAC7BV,KAAK1C,WAAY,E,mEAEX0C,KAAKG,UAAUS,Q,cACrBZ,KAAKjC,a,qJAMDV,GACR,OACEA,EAAOjE,QAAU,GAAgD,QAA3CiE,EAAOwD,aAAaxD,EAAOjE,OAAS,K,mCAK5D4G,KAAK1C,WAAY,EACjB0C,KAAKG,UAAY,O,uCAGF9C,GACf,GAAIA,EAAOjE,OAAS,EAAG,MAAM,IAAIoH,MAAM,gCAEvC,IAAIM,EAAS,CACX,MAAQ,mBACR,MAAQ,gBACR,MAAQ,uBACR,MAAQ,uBACR,MAAQ,uBACR,MAAQ,sBACR,MAAQ,8BAGN9C,EAAQX,EAAOwD,aAAaxD,EAAOjE,OAAS,GAChD,GAAI4E,KAAS8C,EACX,MAAM,IAAIN,MAAMM,EAAO9C,M,8BAKzB,GAAIgC,KAAKE,KAAM,MAAM,IAAIM,MAAM,kBAC/BR,KAAKE,MAAO,I,gCAIZF,KAAKE,MAAO,I,4CAGQa,GACpB,IAD8B,EAC1BC,EAAU,EADgB,cAERD,GAFQ,IAE9B,2BAAgC,CAAC,IAAtBE,EAAqB,QAC9BD,GAAWzB,EAAkB0B,IAHD,8BAM9B,OADgB,IAAZD,IAAkBA,EAjFG,KAkFlBA,I,4CAGaA,GACpB,IAAIE,EAAc,GAClB,GAAgB,IAAZF,GAvFqB,MAuFDA,EACtBE,EAAYC,KAAK,iBAEjB,IAAK,IAAMF,KAAW1B,EAChBA,EAAkB0B,GAAWD,GAASE,EAAYC,KAAKF,GAG/D,OAAOC,I,+BAGAE,GAAiB,IAAD,OACnB3C,EAAY4C,EAAOC,MAAMtB,KAAKW,cAC9BY,EAAmBzG,KAAK0G,MAAMJ,GAAX,OACnBK,EAAS,EAqBb,OApBAF,EAAiBG,SAAQ,SAACC,GACxB,IAAIC,EAAWD,EAAO,SAClBZ,EAAW,EAAKc,sBAAsBF,EAAO,UACjD,GAAIC,EAASxI,OAAS,GACpB,MAAM,IAAIoH,MAAJ,sCAC2BoB,EAD3B,uBACkDA,EAASxI,SAEnE,GAAIqI,EAAS,EAAIG,EAASxI,QAAU,EAAKuH,aACvC,MAAM,IAAIH,MAAJ,2DAGR/B,EAAUgD,KAAYG,EAASxI,OAAS,EACxCqF,EAAUgD,KAAY,EACtBhD,EAAUgD,KAAYV,EACtBtC,EAAUqD,MAAMF,EAAUH,GAC1BA,GAAUG,EAASxI,UAGrBqF,EAAUgD,KAAY,EACtBhD,EAAUgD,KAAY,EACfhD,I,8BAGDA,GAKN,IAJA,IAAIsD,EAAiB,GACjBC,EAAc,GACdP,EAAS,EACTQ,EAAc,KACL,CACX,IAAIC,EAAMzD,EAAUgD,GACpB,GAAY,IAARS,EAAW,MACf,IAAIC,EAAmC,MAA1B1D,EAAUgD,EAAS,GAC5BV,EAAWtC,EAAUgD,EAAS,GAC9BS,EAAM,KACRD,GAAe,CAACR,EAAD,4BAA8BS,EAA9B,iBACjB,IAAIE,EAAW,CACbR,SAAUnD,EAAU4D,MAAMZ,EAAS,EAAGA,EAAS,EAAIS,GAAKjE,WACxD8C,SAAUf,KAAKsC,sBAAsBvB,IAEvCoB,EAASH,EAAYb,KAAKiB,GAAYL,EAAeZ,KAAKiB,GAC1DX,GAAUS,EAAM,EAElB,MAAO,CACLK,OAAQR,EACRS,kCAAmCR,EACnCS,wBAAyBR,EACzBS,cAAejE,EAAUR,SAAS,U,qFAIV0E,EAAOC,G,uFACd5C,KAAKG,UAAU0C,KAChC,IACA7D,EAAQM,uBACRsD,EAAU,IAAO,EACjB,EACAvB,EAAOyB,KAAKH,GACZ3C,KAAKC,iB,cANH5C,E,OAQC2C,KAAK+C,UAAU1F,IAAS2C,KAAKgD,iBAAiB3F,G,kBAC5CA,G,6QAGP2C,KAAKiD,Q,kBAEgBjD,KAAKG,UAAU0C,KAChC,IACA7D,EAAQG,qBACR,EACA,EACAkC,EAAO,GACPrB,KAAKC,iB,cANH5C,E,OAQC2C,KAAK+C,UAAU1F,IAAS2C,KAAKgD,iBAAiB3F,GAEnDA,EAASA,EAAOgF,MAAM,EAAGhF,EAAOjE,OAAS,G,SAGnCqI,EAAS,EACTyB,EAAkB7F,EAAOoE,KAC7B0B,EAAW9F,EAAOgF,MAAMZ,EAAQA,EAASyB,GAAiBjF,WAC1DwD,GAAUyB,EACNE,EAAqB/F,EAAOoE,KAChC4B,EAAchG,EACXgF,MAAMZ,EAAQA,EAAS2B,GACvBnF,W,kBACI,CAACkF,EAAUE,I,wCAEZ,IAAI7C,MAAJ,+D,yBAKRR,KAAKsD,U,0SAKPtD,KAAKiD,Q,kBAEgBjD,KAAKG,UAAU0C,KAChC,IACA7D,EAAQI,uBACR,EACA,EACAiC,EAAO,GACPrB,KAAKC,iB,UANH5C,E,OAQC2C,KAAK+C,UAAU1F,IAAS2C,KAAKgD,iBAAiB3F,GAE7B,KADtBA,EAASA,EAAOgF,MAAM,EAAGhF,EAAOjE,OAAS,IAC9BA,O,sBACH,IAAIoH,MAAJ,2CAA8CnD,EAAOjE,S,cAEzDuH,EAAetD,EAAOkG,aAAa,EAAG,GACtCC,EAAgBnG,EAAO,GACvBoG,EAA2BpG,EAAO,G,kBAC/B,CAAEsD,eAAc6C,gBAAeC,6B,yBAEtCzD,KAAKsD,U,0RAKPtD,KAAKiD,Q,SAECxE,EAAY4C,EAAOC,MAAM,G,YACtB7C,EAAUrF,OAAS4G,KAAKW,c,iCACVX,KAAKG,UAAU0C,KAChC,IACA7D,EAAQK,uBACR,EACA,EACAgC,EAAO,GACPrB,KAAKC,iB,UANH5C,E,OAQC2C,KAAK+C,UAAU1F,IAAS2C,KAAKgD,iBAAiB3F,GACnDoB,EAAY4C,EAAOqC,OAAO,CACxBjF,EACA4C,EAAOyB,KAAKzF,EAAOgF,MAAM,GAAI,QAEb,MAAdhF,EAAO,IAAeoB,EAAUrF,OAAS4G,KAAKW,c,uBAC1C,IAAIH,MAAJ,UACDR,KAAKW,aADJ,qCAC6ClC,EAAUrF,OADvD,qB,wDAKH4G,KAAK2D,QAAQlF,I,yBAEpBuB,KAAKsD,U,+MAIYM,G,8EACnB5D,KAAKiD,Q,SAGsB,KADrBxE,EAAYuB,KAAK6D,SAASD,IAChBxK,O,sBACN,IAAIoH,MAAM,mB,OAETsD,EAAI,E,YAAGA,EAAIrF,EAAUrF,Q,wBACxBuJ,EAAQlE,EAAU4D,MAAMyB,EAAGA,EAAI,K,UAC7B9D,KAAK+D,sBACTpB,EACAmB,EAAInB,EAAMvJ,SAAWqF,EAAUrF,Q,QAJG0K,GAAK,I,wCAQ3C9D,KAAKsD,U,yIAKI5G,Q","file":"static/js/main.b4c224bd.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.aeffe6a7.svg\";","import React, { useRef, useCallback, useState } from \"react\";\nimport \"./index.css\";\n\nfunction RestoreButton({ text, color, disabled, hidden, onClick }) {\n  const [isLoading, setLoading] = useState(false);\n  const file = useRef(null);\n\n  const hasFileInputBeenCanceled = () => {\n    if (!file.current.value.length) setLoading(false);\n    document.body.onfocus = null;\n  };\n\n  const onTriggerFileSelect = useCallback(() => {\n    setLoading(true);\n    document.body.onfocus = hasFileInputBeenCanceled;\n    file.current && file.current.click();\n  }, []);\n\n  const onSelectedFileChanged = useCallback(\n    (event) => {\n      event.target.files[0].text().then((text) => {\n        event.target.value = \"\";\n        onClick(text).then(() => setLoading(false));\n      });\n    },\n    [onClick]\n  );\n\n  return (\n    <button\n      className=\"RestoreButton\"\n      disabled={isLoading | disabled}\n      onClick={isLoading ? null : onTriggerFileSelect}\n      style={{\n        margin: \"10px\",\n        backgroundColor: color,\n        display: hidden ? \"none\" : true,\n      }}\n    >\n      {isLoading ? \"Loading…\" : text}\n      <input\n        type=\"file\"\n        ref={file}\n        onChange={onSelectedFileChanged}\n        accept=\".json\"\n        style={{ display: \"none\" }}\n      />\n    </button>\n  );\n}\n\nexport default RestoreButton;\n","import React, { useState, useCallback } from \"react\";\nimport \"./index.css\";\n\nfunction downloadFile(fileData) {\n  var blob = new Blob([JSON.stringify(fileData, null, 4)], {\n    type: \"application/json;charset=utf-8\",\n  });\n  var url = URL.createObjectURL(blob);\n  var elem = document.createElement(\"a\");\n  elem.href = url;\n  elem.download = \"backup.json\";\n  document.body.appendChild(elem);\n  elem.click();\n  document.body.removeChild(elem);\n}\n\nfunction BackupButton({ text, color, disabled, hidden, onClick }) {\n  const [isLoading, setLoading] = useState(false);\n\n  const onTriggerRunThenSaveFile = useCallback(() => {\n    setLoading(true);\n    onClick().then((fileData) => {\n      if (fileData) downloadFile(fileData);\n      setLoading(false);\n    });\n  }, [onClick]);\n\n  return (\n    <button\n      className=\"BackupButton\"\n      disabled={isLoading | disabled}\n      onClick={isLoading ? null : onTriggerRunThenSaveFile}\n      style={{\n        margin: \"10px\",\n        backgroundColor: color,\n        display: hidden ? \"none\" : true,\n      }}\n    >\n      {isLoading ? \"Loading…\" : text}\n    </button>\n  );\n}\n\nexport default BackupButton;\n","import React, { useState } from \"react\";\n\nimport {\n  Accordion,\n  AccordionItem,\n  AccordionItemHeading,\n  AccordionItemButton,\n  AccordionItemPanel,\n} from \"react-accessible-accordion\";\nimport ReactMarkdown from \"react-markdown\";\nimport \"./index.css\";\n\nexport default function AppExplanations() {\n  const [expandedItems, setexpandedItems] = useState([]);\n\n  // In case the user expands a node that is barely visible, we scroll the page to display it fully\n  function handleExpand(update) {\n    if (update.length > expandedItems.length) {\n      const newExpandedItemUUID = update[update.length - 1];\n      const itemButtonBottom = document\n        .getElementById(`accordion__panel-${newExpandedItemUUID}`)\n        .getBoundingClientRect().bottom;\n      if (itemButtonBottom > window.innerHeight) {\n        window.scrollBy(0, itemButtonBottom - window.innerHeight);\n      }\n    }\n    setexpandedItems(update);\n  }\n\n  const whatIsThisWebApp_help =\n    // eslint-disable-next-line\n    \"This Web App allows you to backup/restore the list of `password nicknames` stored inside the `Passwords app` on your Ledger Nano S/ Nano X.  \\n\\\n    It is useful to have such a backup when you update the Passwords app on your device, or the device firmware, because the list gets erased. Another case where it's practical to have a nickname backup is when you loose your device: Restoring the [24-words recovery phrase](https://www.ledger.com/academy/crypto/what-is-a-recovery-phrase) is necessary but not sufficient to restore your passwords, you need your nickname list as well.  \\n\\\n    The backup consists in a human readable `backup.json` file containing a dump of the 4096 bytes of application storage.  \\n\\\n    Note that all operations of this Web App are done locally on your computer, there are no external communications occurring.\";\n\n  const whatIsTheLedgerPasswordsApp_help =\n    \"Look [here](https://github.com/LedgerHQ/app-passwords/blob/master/README.md) for more information on the device application itself.\";\n\n  const howToUseThisWebApp_help =\n    // eslint-disable-next-line\n    '* Connect your Nano S/X to your computer and open the `Passwords app`.\\n* You can now click on the big `Connect` button, and if it succeeds the `Backup` and `Restore` buttons should replace the previous button. If you have troubles with this step, have a look [here](https://support.ledger.com/hc/en-us/articles/115005165269-Fix-connection-issues). \\n* Either click on `Backup` or `Restore` depending on what you want to do:  \\n\\\n    * `Backup` will prompt a screen requesting your approval on your device (`\"Transfer metadatas ?\"`), then save a backup file. This is your backup. it\\'s not confidential, so for instance you can send it to yourself by e-mail to never loose it.  \\n\\\n    * `Restore` will prompt a file input dialog where you should indicate a previous backup file. A prompt (`\"Overwrite metadatas ?\"`) will then request your approval on your device. Done.';\n\n  const whichbrowsersAreSupported_help =\n    \"The communication with the device is done through `WebUSB`, which is currently supported only on `Google Chrome` / `Chromium` / `Brave` for `Linux` and `MacOS`. On `Windows`, you need to first go to `chrome://flags` then search for `Enable new USB backend`, disable it and relaunch Chrome.\";\n\n  const lessCommonUseCases_help =\n    // eslint-disable-next-line\n    \"* If you ever encounter a WTF-kind of error with your passwords app (some or all of your entries are suddenly gone? A password has changed ?), it is wise to first come here and make a backup. You can then have a look inside the backup file to see if something is wrong (You might also want to create an issue [here](https://github.com/LedgerHQ/app-passwords/issues) so we fix your issue for all users). \\n* If you want to add a lot of new passwords, the manual input on the device keyboard will show its limits. You can instead create a backup and edit it manually to add all your new entries. You just have to restore your app with this file and the job is done :)\";\n\n  return (\n    <Accordion allowZeroExpanded allowMultipleExpanded onChange={handleExpand}>\n      <AccordionItem>\n        <AccordionItemHeading>\n          <AccordionItemButton>What is this Web App ?</AccordionItemButton>\n        </AccordionItemHeading>\n        <AccordionItemPanel>\n          <ReactMarkdown\n            className=\"Explanations\"\n            children={whatIsThisWebApp_help}\n          ></ReactMarkdown>\n        </AccordionItemPanel>\n      </AccordionItem>\n      <AccordionItem>\n        <AccordionItemHeading>\n          <AccordionItemButton>\n            What is the Ledger Passwords application ?\n          </AccordionItemButton>\n        </AccordionItemHeading>\n        <AccordionItemPanel>\n          <ReactMarkdown\n            className=\"Explanations\"\n            children={whatIsTheLedgerPasswordsApp_help}\n          ></ReactMarkdown>\n        </AccordionItemPanel>\n      </AccordionItem>\n      <AccordionItem>\n        <AccordionItemHeading>\n          <AccordionItemButton>How to use this Web App ?</AccordionItemButton>\n        </AccordionItemHeading>\n        <AccordionItemPanel>\n          <ReactMarkdown\n            className=\"Explanations\"\n            children={howToUseThisWebApp_help}\n          ></ReactMarkdown>\n        </AccordionItemPanel>\n      </AccordionItem>\n      <AccordionItem>\n        <AccordionItemHeading>\n          <AccordionItemButton>\n            Which web browsers and operating systems are supported ?\n          </AccordionItemButton>\n        </AccordionItemHeading>\n        <AccordionItemPanel>\n          <ReactMarkdown\n            className=\"Explanations\"\n            children={whichbrowsersAreSupported_help}\n          ></ReactMarkdown>\n        </AccordionItemPanel>\n      </AccordionItem>\n      <AccordionItem>\n        <AccordionItemHeading>\n          <AccordionItemButton>Less common use cases</AccordionItemButton>\n        </AccordionItemHeading>\n        <AccordionItemPanel>\n          <ReactMarkdown\n            className=\"Explanations\"\n            children={lessCommonUseCases_help}\n          ></ReactMarkdown>\n        </AccordionItemPanel>\n      </AccordionItem>\n    </Accordion>\n  );\n}\n","import React, { useState } from \"react\";\nimport logo from \"./logo.svg\";\nimport RestoreButton from \"./components/RestoreButton\";\nimport BackupButton from \"./components/BackupButton\";\nimport PasswordsManager from \"./controller/PasswordsManager.js\";\nimport AppExplanations from \"./components/AppExplanations\";\nimport { ToastContainer, toast } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\nimport { listen } from \"@ledgerhq/logs\";\nimport packageJson from \"../package.json\";\nimport \"./App.css\";\n\nconst passwordsManager = new PasswordsManager();\nlisten((log) => {\n  console.log(log);\n});\n\nfunction App() {\n  function ask_device(device_handler, request) {\n    return new Promise(async (resolve) => {\n      let result = null;\n      try {\n        if (!device_handler.connected) {\n          await device_handler.connect();\n          setConnected(true);\n          toast.info(\"Device connected 👌\", { autoClose: false });\n        }\n        if (request) {\n          toast.info(\"Approve action on your device ✨\", { autoClose: false });\n          setBusy(true);\n          result = await request();\n\n          toast.dismiss();\n          toast.success(\"Success 🦄\");\n        }\n      } catch (error) {\n        device_handler.disconnect();\n        setConnected(false);\n        toast.dismiss();\n        toast.error(`${error.toString()} 🙅`);\n      } finally {\n        setBusy(false);\n        resolve(result);\n      }\n    });\n  }\n\n  // const  = new PasswordsManager(true);\n\n  const [isBusy, setBusy] = useState(false);\n  const [isConnected, setConnected] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <ToastContainer hideProgressBar={true} />\n      <div className=\"App-banner\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p className=\"App-title\">Passwords Backup</p>\n      </div>\n      <header className=\"App-header\">\n        <div className=\"Commands\">\n          <BackupButton\n            text=\"Connect\"\n            color=\"#41ccb4\"\n            disabled={isBusy}\n            hidden={isConnected}\n            onClick={() => ask_device(passwordsManager)}\n          />\n          <BackupButton\n            text=\"Backup\"\n            color=\"#41ccb4\"\n            disabled={isBusy}\n            hidden={!isConnected}\n            onClick={() =>\n              ask_device(passwordsManager, () =>\n                passwordsManager.dump_metadatas()\n              )\n            }\n          />\n          <RestoreButton\n            text=\"Restore\"\n            color=\"#FFB86D\"\n            disabled={isBusy}\n            hidden={!isConnected}\n            onClick={(metadatas) =>\n              ask_device(passwordsManager, () =>\n                passwordsManager.load_metadatas(metadatas)\n              )\n            }\n          />\n        </div>\n        <AppExplanations></AppExplanations>\n        <div className=\"App-footer\">\n          <p>\n            A modest Web App built at Ledger with React, hosted by Github. v\n            {`${packageJson.version}`}.{\" \"}\n            <a href=\"https://github.com/LedgerHQ/passwords-backup\">\n              PRs welcomed and appreciated ✨\n            </a>\n          </p>\n        </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n","import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n\nconst insAPDU = Object.freeze({\n  GET_APP_INFO_COMMAND: 0x01,\n  GET_APP_CONFIG_COMMAND: 0x03,\n  DUMP_METADATAS_COMMAND: 0x04,\n  LOAD_METADATAS_COMMAND: 0x05,\n});\n\nconst passwordsCharsets = Object.freeze({\n  UPPERCASE: 1,\n  LOWERCASE: 2,\n  NUMBERS: 4,\n  MINUS: 8,\n  UNDERLINE: 16,\n  SPACE: 32,\n  SPECIAL: 64,\n  BRACKETS: 128,\n});\n\nconst allPasswordsCharsets = 0xff;\n\nclass PasswordsManager {\n  constructor() {\n    this.allowedStatuses = [\n      0x9000,\n      0x6985,\n      0x6a86,\n      0x6a87,\n      0x6d00,\n      0x6e00,\n      0xb000,\n    ];\n    this.connected = false;\n    this.busy = false;\n    this.transport = null;\n  }\n\n  async connect() {\n    if (!this.connected) {\n      if (!this.transport) this.transport = await TransportWebUSB.create();\n      try {\n        const [appName, version] = await this.getAppInfo();\n        if (appName.toString() !== \"Passwords\")\n          throw new Error(\"The Passwords app is not opened on the device\");\n        this.version = version;\n        let appConfig = await this.getAppConfig();\n        this.storage_size = appConfig[\"storage_size\"];\n        this.connected = true;\n      } catch (error) {\n        await this.transport.close();\n        this.disconnect();\n        throw error;\n      }\n    }\n  }\n\n  isSuccess(result) {\n    return (\n      result.length >= 2 && result.readUInt16BE(result.length - 2) === 0x9000\n    );\n  }\n\n  disconnect() {\n    this.connected = false;\n    this.transport = null;\n  }\n\n  mapProtocolError(result) {\n    if (result.length < 2) throw new Error(\"Response length is too small\");\n\n    var errors = {\n      0x6985: \"Action cancelled\",\n      0x6a86: \"SW_WRONG_P1P2\",\n      0x6a87: \"SW_WRONG_DATA_LENGTH\",\n      0x6d00: \"SW_INS_NOT_SUPPORTED\",\n      0x6e00: \"SW_CLA_NOT_SUPPORTED\",\n      0xb000: \"SW_APPNAME_TOO_LONG\",\n      0x6f10: \"SW_METADATAS_PARSING_ERROR\",\n    };\n\n    let error = result.readUInt16BE(result.length - 2);\n    if (error in errors) {\n      throw new Error(errors[error]);\n    }\n  }\n\n  _lock() {\n    if (this.busy) throw new Error(\"Device is busy\");\n    this.busy = true;\n  }\n\n  _unlock() {\n    this.busy = false;\n  }\n\n  _charsetListToBitmask(charsets) {\n    let bitmask = 0x00;\n    for (const charset of charsets) {\n      bitmask |= passwordsCharsets[charset];\n    }\n    if (bitmask === 0x00) bitmask = allPasswordsCharsets;\n    return bitmask;\n  }\n\n  _bitmaskToCharsetList(bitmask) {\n    let charsetList = [];\n    if (bitmask === 0x00 || bitmask === allPasswordsCharsets) {\n      charsetList.push(\"ALL_SETS\");\n    } else {\n      for (const charset in passwordsCharsets) {\n        if (passwordsCharsets[charset] & bitmask) charsetList.push(charset);\n      }\n    }\n    return charsetList;\n  }\n\n  _toBytes(json_metadatas) {\n    let metadatas = Buffer.alloc(this.storage_size);\n    let parsed_metadatas = JSON.parse(json_metadatas)[\"parsed\"];\n    let offset = 0;\n    parsed_metadatas.forEach((element) => {\n      let nickname = element[\"nickname\"];\n      let charsets = this._charsetListToBitmask(element[\"charsets\"]);\n      if (nickname.length > 19)\n        throw new Error(\n          `Nickname too long (19 max): ${nickname} has length ${nickname.length}`\n        );\n      if (offset + 3 + nickname.length >= this.storage_size)\n        throw new Error(\n          `Not enough memory on this device to restore this backup`\n        );\n      metadatas[offset++] = nickname.length + 1;\n      metadatas[offset++] = 0x00;\n      metadatas[offset++] = charsets;\n      metadatas.write(nickname, offset);\n      offset += nickname.length;\n    });\n    // mark free space at the end of the buffer\n    metadatas[offset++] = 0x00;\n    metadatas[offset++] = 0x00;\n    return metadatas;\n  }\n\n  _toJSON(metadatas) {\n    let metadatas_list = [];\n    let erased_list = [];\n    let offset = 0;\n    let corruptions = [];\n    while (true) {\n      let len = metadatas[offset];\n      if (len === 0) break;\n      let erased = metadatas[offset + 1] === 0xff ? true : false;\n      let charsets = metadatas[offset + 2];\n      if (len > 19 + 1)\n        corruptions += [offset, `nickname too long ${len}, max is 19`];\n      let metadata = {\n        nickname: metadatas.slice(offset + 3, offset + 2 + len).toString(),\n        charsets: this._bitmaskToCharsetList(charsets),\n      };\n      erased ? erased_list.push(metadata) : metadatas_list.push(metadata);\n      offset += len + 2;\n    }\n    return {\n      parsed: metadatas_list,\n      nicknames_erased_but_still_stored: erased_list,\n      corruptions_encountered: corruptions,\n      raw_metadatas: metadatas.toString(\"hex\"),\n    };\n  }\n\n  async _load_metadatas_chunk(chunk, is_last) {\n    let result = await this.transport.send(\n      0xe0,\n      insAPDU.LOAD_METADATAS_COMMAND,\n      is_last ? 0xff : 0x00,\n      0x00,\n      Buffer.from(chunk),\n      this.allowedStatuses\n    );\n    if (!this.isSuccess(result)) this.mapProtocolError(result);\n    return result;\n  }\n  async getAppInfo() {\n    this._lock();\n    try {\n      let result = await this.transport.send(\n        0xb0,\n        insAPDU.GET_APP_INFO_COMMAND,\n        0x00,\n        0x00,\n        Buffer(0),\n        this.allowedStatuses\n      );\n      if (!this.isSuccess(result)) this.mapProtocolError(result);\n\n      result = result.slice(0, result.length - 2);\n      let app_name, app_version;\n      try {\n        let offset = 1;\n        let app_name_length = result[offset++];\n        app_name = result.slice(offset, offset + app_name_length).toString();\n        offset += app_name_length;\n        let app_version_length = result[offset++];\n        app_version = result\n          .slice(offset, offset + app_version_length)\n          .toString();\n        return [app_name, app_version];\n      } catch (error) {\n        throw new Error(\n          `Unexpected result from device, parsing error: ${error}`\n        );\n      }\n    } finally {\n      this._unlock();\n    }\n  }\n\n  async getAppConfig() {\n    this._lock();\n    try {\n      let result = await this.transport.send(\n        0xe0,\n        insAPDU.GET_APP_CONFIG_COMMAND,\n        0x00,\n        0x00,\n        Buffer(0),\n        this.allowedStatuses\n      );\n      if (!this.isSuccess(result)) this.mapProtocolError(result);\n      result = result.slice(0, result.length - 2);\n      if (result.length !== 6)\n        throw new Error(`Can't parse app config of length ${result.length}`);\n\n      let storage_size = result.readUInt32BE(0, 4);\n      let keyboard_type = result[4];\n      let press_enter_after_typing = result[5];\n      return { storage_size, keyboard_type, press_enter_after_typing };\n    } finally {\n      this._unlock();\n    }\n  }\n\n  async dump_metadatas() {\n    this._lock();\n    try {\n      let metadatas = Buffer.alloc(0);\n      while (metadatas.length < this.storage_size) {\n        let result = await this.transport.send(\n          0xe0,\n          insAPDU.DUMP_METADATAS_COMMAND,\n          0x00,\n          0x00,\n          Buffer(0),\n          this.allowedStatuses\n        );\n        if (!this.isSuccess(result)) this.mapProtocolError(result);\n        metadatas = Buffer.concat([\n          metadatas,\n          Buffer.from(result.slice(1, -2)),\n        ]);\n        if (result[0] === 0xff && metadatas.length < this.storage_size) {\n          throw new Error(\n            `${this.storage_size} bytes requested but only ${metadatas.length} bytes available`\n          );\n        }\n      }\n      return this._toJSON(metadatas);\n    } finally {\n      this._unlock();\n    }\n  }\n\n  async load_metadatas(JSON_metadatas) {\n    this._lock();\n    try {\n      let metadatas = this._toBytes(JSON_metadatas);\n      if (metadatas.length === 0) {\n        throw new Error(\"No data to load\");\n      }\n      for (let i = 0; i < metadatas.length; i += 0xff) {\n        let chunk = metadatas.slice(i, i + 0xff);\n        await this._load_metadatas_chunk(\n          chunk,\n          i + chunk.length === metadatas.length ? true : false\n        );\n      }\n    } finally {\n      this._unlock();\n    }\n  }\n}\n\nexport default PasswordsManager;\n"],"sourceRoot":""}