/*******************************************************************************
 *   Password Manager application
 *   (c) 2017-2023 Ledger SAS
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ********************************************************************************/

#include "os.h"
#include "hid_mapping.h"

#define KEYCODE_START    0x20
#define MOD_MASK_LENGTH  12
#define MOD2_MASK_LENGTH 24
#define MAPPING_LENGTH   95

static const uint8_t TWOPOWER[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

typedef struct mapping_s {
    uint8_t qwerty;
    uint8_t azerty;
} mapping_t;

static const mapping_t MAP[] = {
    // alt mask from ascii 0x20
    {0x00, 0x08},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x00, 0x01},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x00, 0x78},
    {0x00, 0x01},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x00, 0x78},
    // shift mask from ascii 0x20
    {0x7E, 0x20},
    {0x0f, 0xc8},
    {0x00, 0xff},
    {0xd4, 0xc3},
    {0xff, 0xfe},
    {0xff, 0xff},
    {0xff, 0xff},
    {0xc7, 0x07},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x00, 0x00},
    {0x78, 0x00},
    // key codes from ascii 0x20
    {0x2c, 0x2c},  // ' ' (i = 32 - 8)
    {0x1e, 0x38},  // '!'
    {0x34, 0x20},  // '"'
    {0x20, 0x20},  // '#'
    {0x21, 0x30},  // '$'
    {0x22, 0x34},  // '%'
    {0x24, 0x1e},  // '&'
    {0x34, 0x21},  // '''
    {0x26, 0x22},  // '('
    {0x27, 0x2d},  // ')'
    {0x25, 0x32},  // '*'
    {0x2e, 0x2e},  // '+'
    {0x36, 0x10},  // ','
    {0x2d, 0x23},  // '-'
    {0x37, 0x36},  // '.'
    {0x38, 0x37},  // '/'
    {0x27, 0x27},  // '0' (i = 48 - 8)
    {0x1e, 0x1e},  // '1'
    {0x1f, 0x1f},
    {0x20, 0x20},
    {0x21, 0x21},
    {0x22, 0x22},
    {0x23, 0x23},
    {0x24, 0x24},
    {0x25, 0x25},
    {0x26, 0x26},  // '9'
    {0x33, 0x37},  // ':'
    {0x33, 0x36},  // ';'
    {0x36, 0x64},  // '<'
    {0x2e, 0x2e},  // '='
    {0x37, 0x64},  // '>'
    {0x38, 0x10},  // '?'
    {0x1f, 0x27},  // '@'
    {0x04, 0x14},  // 'A' (i = 65 - 8)
    {0x05, 0x05},
    {0x06, 0x06},
    {0x07, 0x07},
    {0x08, 0x08},
    {0x09, 0x09},
    {0x0a, 0x0a},
    {0x0b, 0x0b},
    {0x0c, 0x0c},
    {0x0d, 0x0d},
    {0x0e, 0x0e},
    {0x0f, 0x0f},
    {0x10, 0x33},
    {0x11, 0x11},
    {0x12, 0x12},
    {0x13, 0x13},
    {0x14, 0x04},
    {0x15, 0x15},
    {0x16, 0x16},
    {0x17, 0x17},
    {0x18, 0x18},
    {0x19, 0x19},
    {0x1a, 0x1d},
    {0x1b, 0x1b},
    {0x1c, 0x1c},
    {0x1d, 0x1a},  // 'Z' (i = 90 - 8)
    {0x2f, 0x22},  // '['
    {0x31, 0x25},  // '\'
    {0x30, 0x2D},  // ']'
    {0x23, 0x26},  // '^'
    {0x2d, 0x25},  // '_'
    {0x35, 0x24},  // '`'
    {0x04, 0x14},  // 'a' (i = 97 - 8)
    {0x05, 0x05},
    {0x06, 0x06},
    {0x07, 0x07},
    {0x08, 0x08},
    {0x09, 0x09},
    {0x0a, 0x0a},
    {0x0b, 0x0b},
    {0x0c, 0x0c},
    {0x0d, 0x0d},
    {0x0e, 0x0e},
    {0x0f, 0x0f},
    {0x10, 0x33},
    {0x11, 0x11},
    {0x12, 0x12},
    {0x13, 0x13},
    {0x14, 0x04},
    {0x15, 0x15},
    {0x16, 0x16},
    {0x17, 0x17},
    {0x18, 0x18},
    {0x19, 0x19},
    {0x1a, 0x1d},
    {0x1b, 0x1b},
    {0x1c, 0x1c},
    {0x1d, 0x1a},  // 'z' (i = 122 - 8)
    {0x2f, 0x21},  // '{'
    {0x31, 0x23},  // '|'
    {0x30, 0x2e},  // '}'
    {0x35, 0x1f},  // '~' (i = 126 - 8)
};

#if 0
// a good test string
out = "a&b~c#d  {e\"f'g(h  -i  _j)k=l+m  [n  |o  \\p^q  @r  ]s  }t$u!v:w/x;y.z,A?B  <C  >D`EFGHIJKLMNOPQRSTUVWXYZ0123456789";
#endif

static uint8_t get_char(uint8_t index, hid_mapping_t mapping) {
    // all mapping != AZERTY fall back to QWERTY + some adjustments
    return (mapping == HID_MAPPING_AZERTY ? MAP[index].azerty : MAP[index].qwerty);
}

void map_char(hid_mapping_t mapping, uint8_t key, uint8_t *out) {
    uint8_t keyDiv8, twoPower, keyCode;
    bool altUsed, shiftUsed;

    if (key < KEYCODE_START) {
        THROW(EXCEPTION);
    }
    key -= KEYCODE_START;
    if (key > MAPPING_LENGTH) {
        THROW(EXCEPTION);
    }
    keyDiv8 = (key / 8);
    twoPower = TWOPOWER[key % 8];
    altUsed = ((get_char(keyDiv8, mapping) & twoPower) != 0);
    shiftUsed = ((get_char(MOD_MASK_LENGTH + keyDiv8, mapping) & twoPower) != 0);
    keyCode = get_char(MOD2_MASK_LENGTH + key, mapping);
    out[0] = (altUsed ? ALT_KEY : 0x00) | (shiftUsed ? SHIFT_KEY : 0x00);
    out[1] = 0x00;
    out[2] = keyCode;
}
